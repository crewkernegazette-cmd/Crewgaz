<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Dover Dash - The Crewkerne Gazette</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(45deg, #0066cc, #ff0000, #ffffff);
            background-size: 400% 400%;
            animation: unionJackGradient 3s ease infinite;
            font-family: 'Press Start 2P', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        @keyframes unionJackGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .game-container {
            position: relative;
            background: #1a1a2e;
            border: 4px solid #ff0000;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
            max-width: 95vw;
            max-height: 95vh;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, #87ceeb 0%, #e0f6ff 30%, #228b22 70%, #006400 100%);
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ffffff;
            z-index: 10;
        }

        .hidden {
            display: none !important;
        }

        .title {
            font-size: clamp(16px, 4vw, 32px);
            color: #ff0000;
            text-shadow: 2px 2px 0px #ffffff;
            margin-bottom: 20px;
            text-align: center;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        .input-group {
            margin: 20px 0;
            text-align: center;
        }

        .input-group label {
            display: block;
            font-size: clamp(8px, 2vw, 12px);
            margin-bottom: 10px;
            color: #ffffff;
        }

        .input-group input {
            font-family: 'Press Start 2P', monospace;
            font-size: clamp(8px, 2vw, 12px);
            padding: 10px;
            background: #000000;
            color: #00ff00;
            border: 2px solid #ff0000;
            border-radius: 4px;
            text-align: center;
            max-width: 200px;
        }

        .btn {
            font-family: 'Press Start 2P', monospace;
            font-size: clamp(8px, 2vw, 12px);
            padding: 15px 25px;
            margin: 10px;
            background: #ff0000;
            color: #ffffff;
            border: 2px solid #ffffff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-block;
        }

        .btn:hover {
            background: #ffffff;
            color: #ff0000;
            border-color: #ff0000;
            transform: scale(1.05);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            color: #ffffff;
            font-size: clamp(8px, 1.5vw, 12px);
            z-index: 5;
            pointer-events: none;
        }

        .hud-item {
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border: 1px solid #ff0000;
            border-radius: 4px;
        }

        .mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            flex-direction: column;
            gap: 10px;
            z-index: 15;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border: 2px solid #ff0000;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(255,0,0,0.5);
            max-width: 90vw;
        }

        .control-panel-title {
            text-align: center;
            font-size: 8px;
            color: #00ff00;
            margin-bottom: 8px;
            text-shadow: 1px 1px 0px #000000;
        }

        .control-row {
            display: flex;
            gap: 8px;
            justify-content: center;
            align-items: center;
        }

        .mobile-btn {
            width: 50px;
            height: 40px;
            background: linear-gradient(145deg, #ff0000, #cc0000);
            border: 2px solid #ffffff;
            border-radius: 6px;
            color: #ffffff;
            font-size: 8px;
            cursor: pointer;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 2px 2px 0px #000000;
            transition: all 0.2s;
            font-family: 'Press Start 2P', monospace;
        }

        .mobile-btn:active {
            background: linear-gradient(145deg, #ffffff, #cccccc);
            color: #ff0000;
            transform: translate(1px, 1px);
            box-shadow: 1px 1px 0px #000000;
        }

        .mobile-btn.disabled {
            background: #666666;
            color: #999999;
            cursor: not-allowed;
        }

        .mobile-btn .btn-icon {
            font-size: 12px;
            margin-bottom: 2px;
        }

        .mobile-btn .btn-label {
            font-size: 6px;
            line-height: 1;
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
            }
        }

        @media (orientation: landscape) and (max-width: 1024px) {
            .mobile-controls {
                display: flex;
                bottom: 10px;
                transform: translateX(-50%) scale(0.9);
            }
        }

        .leaderboard {
            max-height: 300px;
            overflow-y: auto;
            margin: 20px 0;
            width: 90%;
            max-width: 400px;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,0,0,0.2);
            border: 1px solid #ff0000;
            border-radius: 4px;
            font-size: clamp(6px, 1.5vw, 10px);
        }

        .watermark {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 8px;
            color: rgba(255,255,255,0.5);
            z-index: 15;
            pointer-events: none;
        }

        .achievement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,215,0,0.9);
            color: #000000;
            padding: 20px;
            border: 3px solid #ff0000;
            border-radius: 8px;
            font-size: clamp(10px, 2vw, 14px);
            text-align: center;
            z-index: 20;
            animation: achievementPop 3s ease-out forwards;
        }

        @keyframes achievementPop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            10% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            90% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <!-- Watermark -->
        <div class="watermark">¬© The Crewkerne Gazette</div>
        
        <!-- HUD -->
        <div class="hud hidden" id="gameHUD">
            <div class="hud-item">Score: <span id="scoreDisplay">0</span></div>
            <div class="hud-item">Lives: <span id="livesDisplay">3</span></div>
            <div class="hud-item">Level: <span id="levelDisplay">1</span></div>
            <div class="hud-item">Boats: <span id="boatsDisplay">0</span></div>
        </div>

        <!-- Mobile Controls -->
        <div class="mobile-controls" id="mobileControls">
            <div class="control-panel-title">üá¨üáß BORDER FORCE COMMAND üá¨üáß</div>
            <div class="control-row">
                <div class="mobile-btn" id="upBtn">
                    <div class="btn-icon">‚Üë</div>
                    <div class="btn-label">UP</div>
                </div>
            </div>
            <div class="control-row">
                <div class="mobile-btn" id="leftBtn">
                    <div class="btn-icon">‚Üê</div>
                    <div class="btn-label">LEFT</div>
                </div>
                <div class="mobile-btn" id="droneBtn">
                    <div class="btn-icon">üöÅ</div>
                    <div class="btn-label">DRONE</div>
                </div>
                <div class="mobile-btn" id="rightBtn">
                    <div class="btn-icon">‚Üí</div>
                    <div class="btn-label">RIGHT</div>
                </div>
            </div>
            <div class="control-row">
                <div class="mobile-btn" id="downBtn">
                    <div class="btn-icon">‚Üì</div>
                    <div class="btn-label">DOWN</div>
                </div>
            </div>
        </div>

        <!-- Welcome Screen -->
        <div class="overlay" id="welcomeScreen">
            <div class="title">DOVER DASH</div>
            <p style="text-align: center; font-size: clamp(8px, 1.5vw, 12px); margin: 20px; color: #ffffff;">
                Take control as PM and protect Dover!<br>
                Intercept boats peacefully and redirect them back to France.
            </p>
            <div class="input-group">
                <label for="playerName">Enter Your Name, Future PM:</label>
                <input type="text" id="playerName" placeholder="Your Name" maxlength="20">
            </div>
            <button class="btn" onclick="startSwearingIn()">BECOME PM!</button>
            <button class="btn" onclick="showLeaderboard()">VIEW LEADERBOARD</button>
            <a href="/index.html" class="btn">BACK TO GAZETTE</a>
        </div>

        <!-- Swearing In Screen -->
        <div class="overlay hidden" id="swearingInScreen">
            <div class="title">CONGRATULATIONS!</div>
            <div id="pmAnnouncement" style="font-size: clamp(10px, 2vw, 16px); margin: 20px; text-align: center;"></div>
            <div style="font-size: clamp(12px, 3vw, 24px); margin: 20px; text-align: center; animation: blink 0.5s infinite;">
                NOW FIX THE COUNTRY!
            </div>
            <button class="btn" onclick="startGame()">START MISSION</button>
        </div>

        <!-- Game Over Screen -->
        <div class="overlay hidden" id="gameOverScreen">
            <div class="title">GAME OVER</div>
            <div id="gameOverMessage" style="font-size: clamp(10px, 2vw, 16px); margin: 20px; text-align: center;"></div>
            <div id="finalScore" style="font-size: clamp(12px, 2.5vw, 20px); margin: 20px; text-align: center; color: #00ff00;"></div>
            <button class="btn" onclick="submitScore()">SUBMIT SCORE</button>
            <button class="btn" onclick="restartGame()">TRY AGAIN</button>
            <button class="btn" onclick="showLeaderboard()">LEADERBOARD</button>
        </div>

        <!-- Leaderboard Screen -->
        <div class="overlay hidden" id="leaderboardScreen">
            <div class="title">HALL OF PRIME MINISTERS</div>
            <div class="leaderboard" id="leaderboardList">
                Loading leaderboard...
            </div>
            <button class="btn" onclick="backToWelcome()">BACK</button>
        </div>

        <!-- Pause Screen -->
        <div class="overlay hidden" id="pauseScreen">
            <div class="title">PAUSED</div>
            <p style="text-align: center; margin: 20px;">Game is paused. Press ESC or click Resume to continue.</p>
            <button class="btn" onclick="resumeGame()">RESUME</button>
            <button class="btn" onclick="restartGame()">RESTART</button>
            <button class="btn" onclick="backToWelcome()">MAIN MENU</button>
        </div>
    </div>

    <!-- Audio Elements -->
    <audio id="bgMusic" loop>
        <source src="https://www.soundjay.com/misc/sounds/8-bit-music-loop.mp3" type="audio/mpeg">
    </audio>
    <audio id="interceptSound">
        <source src="https://www.soundjay.com/misc/sounds/beep-07.mp3" type="audio/mpeg">
    </audio>
    <audio id="scoreSound">
        <source src="https://www.soundjay.com/misc/sounds/beep-10.mp3" type="audio/mpeg">
    </audio>
    <audio id="gameOverSound">
        <source src="https://www.soundjay.com/misc/sounds/game-over.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Game State
        let gameState = {
            screen: 'welcome', // welcome, swearing-in, playing, paused, game-over, leaderboard
            score: 0,
            lives: 3,
            level: 1,
            wave: 1,
            waveStartTime: 0,
            isWaveBreak: false,
            waveBreakStartTime: 0,
            playerName: '',
            boats: [],
            illegals: [], // New: illegal immigrant carriers
            defenses: [],
            powerUps: [],
            particles: [],
            events: [],
            achievements: [],
            lastEventTime: 0,
            gameTime: 0,
            isPaused: false,
            keys: {},
            mouse: { x: 0, y: 0, down: false },
            mobile: { left: false, right: false, up: false, down: false, drone: false }
        };

        // Game Configuration
        const CONFIG = {
            canvas: { width: 800, height: 600 },
            fps: 60,
            boats: {
                baseSpawnRate: 4000, // milliseconds - starts slow
                minSpawnRate: 800,   // fastest spawn rate
                speedIncrease: 0.3,  // speed increase per level
                baseSpeed: 0.8,      // starting speed
                size: { width: 30, height: 20 }
            },
            waves: {
                duration: 30000,     // 30 seconds per wave
                breakDuration: 5000, // 5 second break between waves
                difficultyIncrease: 1.5 // multiplier per wave
            },
            player: {
                speed: 5,
                size: { width: 80, height: 20 }
            },
            defenses: {
                drone: { speed: 3, size: 15, cooldown: 2000 },
                forms: { speed: 2, size: 25, cooldown: 4000, unlockScore: 100 },
                delay: { cooldown: 25000, cost: 50, duration: 5000, unlockScore: 300 }
            },
            powerUps: {
                spawnRate: 20000,
                duration: 15000
            },
            events: {
                interval: 45000, // 45 seconds
                duration: 15000  // 15 seconds
            }
        };

        // Canvas and Context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Make canvas responsive
        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerRect = container.getBoundingClientRect();
            const aspectRatio = CONFIG.canvas.width / CONFIG.canvas.height;
            
            let newWidth = Math.min(containerRect.width - 8, window.innerWidth - 20);
            let newHeight = newWidth / aspectRatio;
            
            if (newHeight > window.innerHeight - 100) {
                newHeight = window.innerHeight - 100;
                newWidth = newHeight * aspectRatio;
            }
            
            canvas.style.width = newWidth + 'px';
            canvas.style.height = newHeight + 'px';
        }

        // Game Classes
        class Boat {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = CONFIG.boats.size.width;
                this.height = CONFIG.boats.size.height;
                this.speed = CONFIG.boats.baseSpeed + (gameState.wave * CONFIG.boats.speedIncrease);
                this.intercepted = false;
                this.redirecting = false;
                this.redirectSpeed = 2;
                this.bobOffset = Math.random() * Math.PI * 2;
            }

            update(deltaTime) {
                if (this.redirecting) {
                    this.x += this.redirectSpeed;
                    this.y += Math.sin(Date.now() * 0.005 + this.bobOffset) * 0.5;
                } else {
                    this.x -= this.speed * (deltaTime / 16);
                    this.y += Math.sin(Date.now() * 0.003 + this.bobOffset) * 0.3;
                }
            }

            draw(ctx) {
                ctx.save();
                
                // Boat body
                ctx.fillStyle = this.redirecting ? '#90EE90' : '#8B4513';
                ctx.fillRect(this.x, this.y + 10, this.width, this.height - 10);
                
                // Sail
                ctx.fillStyle = this.redirecting ? '#98FB98' : '#FFFFFF';
                ctx.fillRect(this.x + 10, this.y, 15, 15);
                
                // Mast
                ctx.fillStyle = '#654321';
                ctx.fillRect(this.x + 17, this.y, 2, this.height);
                
                // Flag (French or British depending on direction)
                if (this.redirecting) {
                    // Union Jack
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(this.x + 5, this.y, 8, 6);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(this.x + 6, this.y + 2, 6, 2);
                    ctx.fillStyle = '#0000FF';
                    ctx.fillRect(this.x + 7, this.y + 1, 4, 4);
                } else {
                    // French tricolor
                    ctx.fillStyle = '#0055A4';
                    ctx.fillRect(this.x + 5, this.y, 3, 6);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(this.x + 8, this.y, 2, 6);
                    ctx.fillStyle = '#EF4135';
                    ctx.fillRect(this.x + 10, this.y, 3, 6);
                }
                
                ctx.restore();
            }

            intercept() {
                if (!this.intercepted) {
                    this.intercepted = true;
                    this.redirecting = true;
                    gameState.score += 10;
                    playSound('interceptSound');
                    createParticles(this.x + this.width/2, this.y + this.height/2, '#00FF00', 'INTERCEPTED!');
                }
            }

            isOffScreen() {
                return this.x < -this.width || this.x > CONFIG.canvas.width + this.width;
            }

            reachedDover() {
                return this.x <= 0 && !this.intercepted;
            }
        }

        class BorderPatrolBathtub {
            constructor() {
                this.x = CONFIG.canvas.width / 4;
                this.y = CONFIG.canvas.height / 2;
                this.width = CONFIG.player.size.width;
                this.height = CONFIG.player.size.height;
                this.speed = CONFIG.player.speed;
            }

            update() {
                // Handle input - 4-way movement
                if (gameState.keys['ArrowLeft'] || gameState.mobile.left) {
                    this.x = Math.max(50, this.x - this.speed);
                }
                if (gameState.keys['ArrowRight'] || gameState.mobile.right) {
                    this.x = Math.min(CONFIG.canvas.width - 50 - this.width, this.x + this.speed);
                }
                if (gameState.keys['ArrowUp'] || gameState.mobile.up) {
                    this.y = Math.max(CONFIG.canvas.height * 0.4, this.y - this.speed);
                }
                if (gameState.keys['ArrowDown'] || gameState.mobile.down) {
                    this.y = Math.min(CONFIG.canvas.height - this.height - 20, this.y + this.speed);
                }
            }

            draw(ctx) {
                ctx.save();
                
                // Ship hull
                ctx.fillStyle = '#4169E1'; // Royal blue
                ctx.fillRect(this.x, this.y + 5, this.width, this.height - 5);
                
                // Ship bow (pointed front)
                ctx.fillStyle = '#4169E1';
                ctx.beginPath();
                ctx.moveTo(this.x + this.width, this.y + this.height/2);
                ctx.lineTo(this.x + this.width - 10, this.y + 5);
                ctx.lineTo(this.x + this.width - 10, this.y + this.height - 5);
                ctx.closePath();
                ctx.fill();
                
                // Ship superstructure (bridge)
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(this.x + 15, this.y, 25, 12);
                
                // Ship mast
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(this.x + 25, this.y - 8, 3, 20);
                
                // Union Jack flag
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(this.x + 28, this.y - 8, 16, 10);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(this.x + 30, this.y - 6, 12, 6);
                ctx.fillStyle = '#0000FF';
                ctx.fillRect(this.x + 32, this.y - 5, 8, 4);
                
                // "HMS" text
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '8px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText('HMS DOVER', this.x + this.width/2, this.y + this.height + 12);
                
                // Ship wake (water effect behind)
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                const time = Date.now() * 0.01;
                for (let i = 0; i < 3; i++) {
                    const wakeX = this.x - (i * 5) - 5;
                    const wakeY = this.y + this.height/2 + Math.sin(time + i) * 2;
                    ctx.beginPath();
                    ctx.moveTo(wakeX, wakeY - 3);
                    ctx.lineTo(wakeX - 8, wakeY + 3);
                    ctx.stroke();
                }
                
                ctx.restore();
            }

            checkCollision(boat) {
                return this.x < boat.x + boat.width &&
                       this.x + this.width > boat.x &&
                       this.y < boat.y + boat.height &&
                       this.y + this.height > boat.y;
            }
        }

        class IllegalCarrier {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 50;
                this.height = 30;
                this.speed = CONFIG.boats.baseSpeed * 0.7; // Slower than regular boats
                this.health = 3; // Requires 3 drone hits
                this.destroyed = false;
                this.bobOffset = Math.random() * Math.PI * 2;
            }

            update(deltaTime) {
                if (!this.destroyed) {
                    this.x -= this.speed * (deltaTime / 16);
                    this.y += Math.sin(Date.now() * 0.002 + this.bobOffset) * 0.4;
                }
            }

            draw(ctx) {
                if (this.destroyed) return;
                
                ctx.save();
                
                // Large carrier hull
                ctx.fillStyle = '#2F4F4F'; // Dark slate gray
                ctx.fillRect(this.x, this.y + 8, this.width, this.height - 8);
                
                // Multiple decks
                ctx.fillStyle = '#696969';
                ctx.fillRect(this.x + 5, this.y + 4, this.width - 10, 6);
                ctx.fillRect(this.x + 10, this.y, this.width - 20, 6);
                
                // Smokestack
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(this.x + 20, this.y - 5, 4, 15);
                ctx.fillRect(this.x + 28, this.y - 5, 4, 15);
                
                // Smoke
                ctx.fillStyle = '#696969';
                for (let i = 0; i < 3; i++) {
                    const smokeX = this.x + 22 + (i * 3);
                    const smokeY = this.y - 10 - (i * 4);
                    ctx.beginPath();
                    ctx.arc(smokeX, smokeY, 2 + i, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Warning labels
                ctx.fillStyle = '#FF0000';
                ctx.font = '8px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText('ILLEGAL', this.x + this.width/2, this.y + 20);
                ctx.fillText('CARRIER', this.x + this.width/2, this.y + 28);
                
                // Health indicator
                ctx.fillStyle = '#FF0000';
                for (let i = 0; i < this.health; i++) {
                    ctx.fillRect(this.x + 5 + (i * 8), this.y - 8, 6, 4);
                }
                
                ctx.restore();
            }

            takeDamage() {
                this.health--;
                if (this.health <= 0) {
                    this.destroyed = true;
                    gameState.score += 50; // Big points for destroying carrier
                    createParticles(this.x + this.width/2, this.y + this.height/2, '#FF4500', '+50 CARRIER DESTROYED!');
                    playSound('scoreSound');
                } else {
                    createParticles(this.x + this.width/2, this.y + this.height/2, '#FFD700', `${this.health} HITS LEFT!`);
                }
            }

            isOffScreen() {
                return this.x < -this.width || this.destroyed;
            }

            reachedDover() {
                return this.x <= 0 && !this.destroyed;
            }
        }
            constructor(x, y, targetX, targetY) {
                this.x = x;
                this.y = y;
                this.targetX = targetX;
                this.targetY = targetY;
                this.size = CONFIG.defenses.drone.size;
                this.speed = CONFIG.defenses.drone.speed;
                this.active = true;
                this.life = 3000; // 3 seconds
            }

            update(deltaTime) {
                if (!this.active) return;
                
                this.life -= deltaTime;
                if (this.life <= 0) {
                    this.active = false;
                    return;
                }

                // Move towards target
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 2) {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }
            }

            draw(ctx) {
                if (!this.active) return;
                
                ctx.save();
                
                // Drone body
                ctx.fillStyle = '#4169E1';
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                
                // Rotors
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1;
                const rotorOffset = this.size * 0.6;
                const time = Date.now() * 0.01;
                
                // Spinning rotor effect
                for (let i = 0; i < 4; i++) {
                    const angle = (Math.PI / 2) * i + time;
                    const x = this.x + Math.cos(angle) * rotorOffset;
                    const y = this.y + Math.sin(angle) * rotorOffset;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            }

            checkCollision(boat) {
                if (!this.active) return false;
                
                const dx = this.x - (boat.x + boat.width/2);
                const dy = this.y - (boat.y + boat.height/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                return distance < this.size;
            }
        }

        class BureaucracyForm {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 25;
                this.height = 35;
                this.speed = 2;
                this.rotation = 0;
                this.active = true;
                this.life = 5000; // 5 seconds
            }

            update(deltaTime) {
                if (!this.active) return;
                
                this.life -= deltaTime;
                if (this.life <= 0) {
                    this.active = false;
                    return;
                }

                this.y += this.speed * (deltaTime / 16);
                this.rotation += 0.05;
            }

            draw(ctx) {
                if (!this.active) return;
                
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(this.rotation);
                
                // Form paper
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1;
                ctx.strokeRect(-this.width/2, -this.height/2, this.width, this.height);
                
                // Text lines
                ctx.strokeStyle = '#0000FF';
                for (let i = 0; i < 5; i++) {
                    const y = -10 + (i * 4);
                    ctx.beginPath();
                    ctx.moveTo(-8, y);
                    ctx.lineTo(8, y);
                    ctx.stroke();
                }
                
                // "FORM 27B" text
                ctx.fillStyle = '#FF0000';
                ctx.font = '6px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('FORM', 0, -15);
                ctx.fillText('27B', 0, -8);
                
                ctx.restore();
            }

            checkCollision(boat) {
                if (!this.active) return false;
                
                return this.x < boat.x + boat.width &&
                       this.x + this.width > boat.x &&
                       this.y < boat.y + boat.height &&
                       this.y + this.height > boat.y;
            }
        }

        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // 'teapot', 'crumpet', 'crown'
                this.size = 20;
                this.bobOffset = Math.random() * Math.PI * 2;
                this.collected = false;
                this.life = CONFIG.powerUps.duration;
            }

            update(deltaTime) {
                this.life -= deltaTime;
                this.y += Math.sin(Date.now() * 0.005 + this.bobOffset) * 0.5;
            }

            draw(ctx) {
                ctx.save();
                
                const centerX = this.x + this.size/2;
                const centerY = this.y + this.size/2;
                
                switch(this.type) {
                    case 'teapot':
                        // Teapot (score multiplier)
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(this.x + 5, this.y + 8, 10, 8);
                        ctx.fillRect(this.x + 15, this.y + 10, 3, 2); // spout
                        ctx.fillRect(this.x + 2, this.y + 9, 3, 4); // handle
                        ctx.fillStyle = '#FFD700';
                        ctx.fillRect(this.x + 8, this.y + 5, 4, 3); // lid
                        break;
                        
                    case 'crumpet':
                        // Crumpet (temporary invincibility)
                        ctx.fillStyle = '#DEB887';
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, this.size/2, 0, Math.PI * 2);
                        ctx.fill();
                        // Holes
                        ctx.fillStyle = '#8B7355';
                        for (let i = 0; i < 6; i++) {
                            const angle = (Math.PI * 2 / 6) * i;
                            const holeX = centerX + Math.cos(angle) * 5;
                            const holeY = centerY + Math.sin(angle) * 5;
                            ctx.beginPath();
                            ctx.arc(holeX, holeY, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                        
                    case 'crown':
                        // Crown (bonus points)
                        ctx.fillStyle = '#FFD700';
                        ctx.fillRect(this.x + 3, this.y + 12, 14, 6);
                        // Crown points
                        for (let i = 0; i < 5; i++) {
                            const x = this.x + 4 + (i * 2.5);
                            const height = (i % 2 === 0) ? 8 : 5;
                            ctx.fillRect(x, this.y + 12 - height, 2, height);
                        }
                        // Jewels
                        ctx.fillStyle = '#FF0000';
                        ctx.fillRect(this.x + 9, this.y + 14, 2, 2);
                        break;
                }
                
                ctx.restore();
            }

            checkCollision(bathtub) {
                return this.x < bathtub.x + bathtub.width &&
                       this.x + this.size > bathtub.x &&
                       this.y < bathtub.y + bathtub.height &&
                       this.y + this.size > bathtub.y;
            }
        }

        class Particle {
            constructor(x, y, color, text = '') {
                this.x = x;
                this.y = y;
                this.color = color;
                this.text = text;
                this.life = 60; // frames
                this.velocity = {
                    x: (Math.random() - 0.5) * 2,
                    y: -Math.random() * 3 - 1
                };
                this.size = Math.random() * 4 + 2;
            }

            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.velocity.y += 0.1; // gravity
                this.life--;
                this.size *= 0.98;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life / 60;
                
                if (this.text) {
                    ctx.fillStyle = this.color;
                    ctx.font = '12px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.text, this.x, this.y);
                } else {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // Game Objects
        let player = new BorderPatrolBathtub();
        let lastBoatSpawn = 0;
        let lastDroneUse = 0;
        let lastFormUse = 0;
        let lastPowerUpSpawn = 0;

        // Utility Functions
        function createParticles(x, y, color, text = '') {
            for (let i = 0; i < (text ? 1 : 8); i++) {
                gameState.particles.push(new Particle(x, y, color, i === 0 ? text : ''));
            }
        }

        function playSound(soundId, volume = 0.3) {
            try {
                const audio = document.getElementById(soundId);
                if (audio) {
                    audio.volume = volume;
                    audio.currentTime = 0;
                    audio.play().catch(e => console.log('Audio play failed:', e));
                }
            } catch (e) {
                console.log('Audio error:', e);
            }
        }

        function showAchievement(text) {
            const achievement = document.createElement('div');
            achievement.className = 'achievement';
            achievement.innerHTML = `üèÜ ACHIEVEMENT UNLOCKED!<br>${text}`;
            document.querySelector('.game-container').appendChild(achievement);
            
            setTimeout(() => {
                if (achievement.parentNode) {
                    achievement.parentNode.removeChild(achievement);
                }
            }, 3000);
        }

        function generateTitle(score, stats) {
            if (score >= 1000) return "Defender of Dover";
            if (score >= 500) return "Border Patrol Champion";
            if (score >= 250) return "Channel Guardian";
            if (score >= 100) return "Boat Interceptor";
            if (score >= 50) return "Dover Deputy";
            return "Rookie PM";
        }

        function activateDelay() {
            if (Date.now() - gameState.lastDelayUse < CONFIG.defenses.delay.cooldown) return;
            if (gameState.score < CONFIG.defenses.delay.cost) return;
            
            gameState.score -= CONFIG.defenses.delay.cost;
            gameState.lastDelayUse = Date.now();
            
            // Pause all boats for delay duration
            gameState.boats.forEach(boat => {
                if (!boat.intercepted) {
                    boat.delayStartTime = Date.now();
                    boat.originalSpeed = boat.speed;
                    boat.speed = 0;
                }
            });
            
            // Restore speed after delay
            setTimeout(() => {
                gameState.boats.forEach(boat => {
                    if (boat.delayStartTime && !boat.intercepted) {
                        boat.speed = boat.originalSpeed;
                        delete boat.delayStartTime;
                        delete boat.originalSpeed;
                    }
                });
            }, CONFIG.defenses.delay.duration);
            
            createParticles(CONFIG.canvas.width/2, CONFIG.canvas.height/2, '#FFD700', 'POLICY DELAY!');
            playSound('scoreSound');
        }

        function checkUnlocks() {
            // Unlock forms at 100 points
            if (gameState.score >= CONFIG.defenses.forms.unlockScore && !gameState.unlockedDefenses.includes('forms')) {
                gameState.unlockedDefenses.push('forms');
                showAchievement('FORMS UNLOCKED! Press F or tap FORMS button');
            }
            
            // Unlock delay at 300 points
            if (gameState.score >= CONFIG.defenses.delay.unlockScore && !gameState.unlockedDefenses.includes('delay')) {
                gameState.unlockedDefenses.push('delay');
                showAchievement('POLICY DELAY UNLOCKED! Press D or tap DELAY button');
            }
        }

        function getCurrentSpawnRate() {
            const waveMultiplier = Math.pow(CONFIG.waves.difficultyIncrease, gameState.wave - 1);
            return Math.max(
                CONFIG.boats.minSpawnRate,
                CONFIG.boats.baseSpawnRate / waveMultiplier
            );
        }

        function spawnBoat() {
            const y = Math.random() * (CONFIG.canvas.height - 200) + 100;
            gameState.boats.push(new Boat(CONFIG.canvas.width, y));
        }

        function spawnPowerUp() {
            const types = ['teapot', 'crumpet', 'crown'];
            const type = types[Math.floor(Math.random() * types.length)];
            const x = Math.random() * (CONFIG.canvas.width - 50) + 25;
            const y = Math.random() * (CONFIG.canvas.height - 300) + 100;
            gameState.powerUps.push(new PowerUp(x, y, type));
        }

        function launchDrone() {
            if (Date.now() - lastDroneUse < CONFIG.defenses.drone.cooldown) return;
            
            // Find nearest boat
            let nearestBoat = null;
            let nearestDistance = Infinity;
            
            gameState.boats.forEach(boat => {
                if (!boat.intercepted) {
                    const distance = Math.abs(boat.x - player.x);
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestBoat = boat;
                    }
                }
            });
            
            if (nearestBoat) {
                gameState.defenses.push(new Drone(
                    player.x + player.width/2,
                    player.y,
                    nearestBoat.x + nearestBoat.width/2,
                    nearestBoat.y + nearestBoat.height/2
                ));
                lastDroneUse = Date.now();
                playSound('scoreSound');
            }
        }

        function deployForms() {
            if (Date.now() - lastFormUse < CONFIG.defenses.forms.cooldown) return;
            
            for (let i = 0; i < 3; i++) {
                const x = Math.random() * CONFIG.canvas.width;
                const y = -30;
                gameState.defenses.push(new BureaucracyForm(x, y));
            }
            lastFormUse = Date.now();
            playSound('scoreSound');
        }

        function triggerRandomEvent() {
            const events = [
                {
                    name: "Matt Hancock Dancing",
                    message: "Matt Hancock is dancing on screen!",
                    effect: () => {
                        // Block part of screen temporarily
                        gameState.events.push({
                            type: 'screen_block',
                            duration: 5000,
                            startTime: Date.now()
                        });
                    }
                },
                {
                    name: "Nigel Farage Karaoke",
                    message: "Nigel's karaoke distracts the boats!",
                    effect: () => {
                        gameState.boats.forEach(boat => {
                            if (!boat.intercepted) {
                                boat.speed *= 0.5; // Slow down boats
                            }
                        });
                        setTimeout(() => {
                            gameState.boats.forEach(boat => {
                                boat.speed /= 0.5; // Restore speed
                            });
                        }, 8000);
                    }
                },
                {
                    name: "King Charles Weather Forecast",
                    message: "Royal weather report causes rough seas!",
                    effect: () => {
                        gameState.boats.forEach(boat => {
                            boat.bobOffset += Math.PI; // Increase bobbing
                        });
                    }
                }
            ];
            
            const event = events[Math.floor(Math.random() * events.length)];
            event.effect();
            createParticles(CONFIG.canvas.width/2, 100, '#FFD700', event.message);
        }

        // Game Loop Functions
        function updateGame(deltaTime) {
            if (gameState.isPaused) return;
            
            gameState.gameTime += deltaTime;
            
            // Handle wave system
            if (gameState.isWaveBreak) {
                // Check if wave break is over
                if (Date.now() - gameState.waveBreakStartTime >= CONFIG.waves.breakDuration) {
                    gameState.isWaveBreak = false;
                    gameState.waveStartTime = Date.now();
                    createParticles(CONFIG.canvas.width/2, 100, '#FFD700', `WAVE ${gameState.wave} START!`);
                }
            } else {
                // Check if current wave is complete
                const waveElapsed = Date.now() - gameState.waveStartTime;
                if (waveElapsed >= CONFIG.waves.duration) {
                    gameState.wave++;
                    gameState.isWaveBreak = true;
                    gameState.waveBreakStartTime = Date.now();
                    createParticles(CONFIG.canvas.width/2, 100, '#00FF00', `WAVE ${gameState.wave - 1} COMPLETE!`);
                    playSound('scoreSound');
                }
                
                // Spawn boats based on current wave difficulty
                if (Date.now() - lastBoatSpawn > getCurrentSpawnRate()) {
                    spawnBoat();
                    lastBoatSpawn = Date.now();
                }
            }
            
            // Spawn power-ups
            if (Date.now() - lastPowerUpSpawn > CONFIG.powerUps.spawnRate) {
                spawnPowerUp();
                lastPowerUpSpawn = Date.now();
            }
            
            // Trigger random events
            if (Date.now() - gameState.lastEventTime > CONFIG.events.interval) {
                triggerRandomEvent();
                gameState.lastEventTime = Date.now();
            }
            
            // Update player
            player.update();
            
            // Update boats
            gameState.boats.forEach(boat => {
                boat.update(deltaTime);
                
                // Check collision with player
                if (player.checkCollision(boat) && !boat.intercepted) {
                    boat.intercept();
                }
                
                // Check if boat reached Dover
                if (boat.reachedDover()) {
                    gameState.lives--;
                    gameState.score = Math.max(0, gameState.score - 20);
                    boat.intercepted = true; // Prevent multiple hits
                    createParticles(boat.x, boat.y, '#FF0000', 'BOAT LANDED!');
                    playSound('gameOverSound', 0.2);
                }
            });
            
            // Update defenses
            gameState.defenses.forEach(defense => {
                defense.update(deltaTime);
                
                // Check collisions with boats
                gameState.boats.forEach(boat => {
                    if (!boat.intercepted && defense.checkCollision && defense.checkCollision(boat)) {
                        boat.intercept();
                        if (defense.active !== undefined) {
                            defense.active = false;
                        }
                    }
                });
            });
            
            // Update power-ups
            gameState.powerUps.forEach(powerUp => {
                powerUp.update(deltaTime);
                
                if (!powerUp.collected && powerUp.checkCollision(player)) {
                    powerUp.collected = true;
                    
                    switch(powerUp.type) {
                        case 'teapot':
                            gameState.score += 50;
                            createParticles(powerUp.x, powerUp.y, '#FFD700', '+50 TEA BONUS!');
                            break;
                        case 'crumpet':
                            // Temporary invincibility (visual effect only in this demo)
                            gameState.score += 25;
                            createParticles(powerUp.x, powerUp.y, '#90EE90', 'CRUMPET POWER!');
                            break;
                        case 'crown':
                            gameState.score += 100;
                            createParticles(powerUp.x, powerUp.y, '#FFD700', '+100 ROYAL BONUS!');
                            break;
                    }
                    playSound('scoreSound');
                }
            });
            
            // Update particles
            gameState.particles.forEach(particle => {
                particle.update();
            });
            
            // Clean up dead objects
            gameState.boats = gameState.boats.filter(boat => !boat.isOffScreen());
            gameState.defenses = gameState.defenses.filter(defense => 
                defense.active === undefined || defense.active
            );
            gameState.powerUps = gameState.powerUps.filter(powerUp => 
                powerUp.life > 0 && !powerUp.collected
            );
            gameState.particles = gameState.particles.filter(particle => particle.life > 0);
            
            // Check unlocks
            checkUnlocks();
            
            // Update mobile controls
            updateMobileControls();
            
            // Check game over
            if (gameState.lives <= 0) {
                endGame();
            }
            
            // Update HUD
            updateHUD();
        }

        function drawGame() {
            // Clear canvas with gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.canvas.height);
            gradient.addColorStop(0, '#87CEEB'); // Sky blue
            gradient.addColorStop(0.3, '#E0F6FF'); // Light blue
            gradient.addColorStop(0.7, '#228B22'); // Forest green
            gradient.addColorStop(1, '#006400');   // Dark green
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);
            
            // Draw Dover cliffs (left side - England)
            ctx.fillStyle = '#F5F5DC';
            ctx.fillRect(0, CONFIG.canvas.height * 0.4, 50, CONFIG.canvas.height * 0.6);
            
            // Draw England label and flag
            ctx.fillStyle = '#000000';
            ctx.font = '12px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('ENGLAND', 25, CONFIG.canvas.height * 0.35);
            
            // English flag (Union Jack) - simplified
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(5, CONFIG.canvas.height * 0.25, 40, 24);
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(5, CONFIG.canvas.height * 0.25 + 10, 40, 4);
            ctx.fillRect(23, CONFIG.canvas.height * 0.25, 4, 24);
            ctx.fillStyle = '#0000FF';
            ctx.fillRect(7, CONFIG.canvas.height * 0.25 + 2, 36, 2);
            ctx.fillRect(7, CONFIG.canvas.height * 0.25 + 20, 36, 2);
            
            // Draw France coastline (right side)
            ctx.fillStyle = '#D2B48C';
            ctx.fillRect(CONFIG.canvas.width - 30, CONFIG.canvas.height * 0.5, 30, CONFIG.canvas.height * 0.5);
            
            // Draw France label and flag
            ctx.fillStyle = '#000000';
            ctx.font = '12px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('FRANCE', CONFIG.canvas.width - 15, CONFIG.canvas.height * 0.45);
            
            // French flag (tricolor) - vertical
            ctx.fillStyle = '#0055A4'; // Blue
            ctx.fillRect(CONFIG.canvas.width - 25, CONFIG.canvas.height * 0.3, 8, 24);
            ctx.fillStyle = '#FFFFFF'; // White
            ctx.fillRect(CONFIG.canvas.width - 17, CONFIG.canvas.height * 0.3, 8, 24);
            ctx.fillStyle = '#EF4135'; // Red
            ctx.fillRect(CONFIG.canvas.width - 9, CONFIG.canvas.height * 0.3, 8, 24);
            
            // Draw water
            ctx.fillStyle = '#4682B4';
            ctx.globalAlpha = 0.7;
            ctx.fillRect(50, CONFIG.canvas.height * 0.4, CONFIG.canvas.width - 80, CONFIG.canvas.height * 0.6);
            ctx.globalAlpha = 1;
            
            // Draw wave effects
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            const waveOffset = Date.now() * 0.005;
            for (let x = 50; x < CONFIG.canvas.width - 30; x += 20) {
                for (let y = CONFIG.canvas.height * 0.5; y < CONFIG.canvas.height; y += 40) {
                    const waveY = y + Math.sin(x * 0.02 + waveOffset) * 3;
                    ctx.beginPath();
                    ctx.moveTo(x, waveY);
                    ctx.lineTo(x + 10, waveY);
                    ctx.stroke();
                }
            }
            
            // Draw wave information
            if (gameState.isWaveBreak) {
                ctx.fillStyle = '#FFD700';
                ctx.font = '24px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(`WAVE ${gameState.wave} INCOMING...`, CONFIG.canvas.width/2, CONFIG.canvas.height/2 - 50);
                
                const timeLeft = Math.ceil((CONFIG.waves.breakDuration - (Date.now() - gameState.waveBreakStartTime)) / 1000);
                ctx.font = '16px "Press Start 2P"';
                ctx.fillText(`Get Ready: ${timeLeft}s`, CONFIG.canvas.width/2, CONFIG.canvas.height/2);
            } else {
                // Show current wave
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(CONFIG.canvas.width - 150, 10, 140, 30);
                ctx.fillStyle = '#FFD700';
                ctx.font = '12px "Press Start 2P"';
                ctx.textAlign = 'left';
                ctx.fillText(`WAVE ${gameState.wave}`, CONFIG.canvas.width - 145, 30);
            }
            
            // Draw objects
            gameState.boats.forEach(boat => boat.draw(ctx));
            gameState.defenses.forEach(defense => defense.draw(ctx));
            gameState.powerUps.forEach(powerUp => powerUp.draw(ctx));
            player.draw(ctx);
            gameState.particles.forEach(particle => particle.draw(ctx));
            
            // Draw event effects
            gameState.events.forEach(event => {
                if (event.type === 'screen_block') {
                    const elapsed = Date.now() - event.startTime;
                    if (elapsed < event.duration) {
                        ctx.fillStyle = 'rgba(255, 0, 255, 0.3)';
                        ctx.fillRect(CONFIG.canvas.width * 0.3, 0, CONFIG.canvas.width * 0.4, CONFIG.canvas.height);
                        
                        ctx.fillStyle = '#FF00FF';
                        ctx.font = '16px "Press Start 2P"';
                        ctx.textAlign = 'center';
                        ctx.fillText('MATT DANCING!', CONFIG.canvas.width/2, CONFIG.canvas.height/2);
                    }
                }
            });
        }

        function updateHUD() {
            document.getElementById('scoreDisplay').textContent = gameState.score;
            document.getElementById('livesDisplay').textContent = gameState.lives;
            document.getElementById('levelDisplay').textContent = gameState.level;
            document.getElementById('boatsDisplay').textContent = gameState.boats.filter(b => !b.intercepted).length;
        }

        // Game State Functions
        function startSwearingIn() {
            const name = document.getElementById('playerName').value.trim();
            if (!name) {
                alert('Please enter your name, future PM!');
                return;
            }
            
            gameState.playerName = name;
            gameState.screen = 'swearing-in';
            
            document.getElementById('welcomeScreen').classList.add('hidden');
            document.getElementById('swearingInScreen').classList.remove('hidden');
            
            const announcement = document.getElementById('pmAnnouncement');
            announcement.innerHTML = `PM ${name.toUpperCase()}!<br>üéâ SWORN IN AS PRIME MINISTER! üéâ`;
            
            // Play ceremony sound
            playSound('scoreSound');
            
            // Create confetti effect
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    createParticles(
                        Math.random() * CONFIG.canvas.width,
                        -10,
                        ['#FF0000', '#FFFFFF', '#0000FF'][Math.floor(Math.random() * 3)]
                    );
                }, i * 100);
            }
        }

        function startGame() {
            gameState.screen = 'playing';
            gameState.score = 0;
            gameState.lives = 3;
            gameState.level = 1;
            gameState.wave = 1;
            gameState.waveStartTime = Date.now();
            gameState.isWaveBreak = false;
            gameState.boats = [];
            gameState.defenses = [];
            gameState.powerUps = [];
            gameState.particles = [];
            gameState.events = [];
            gameState.gameTime = 0;
            gameState.lastEventTime = Date.now();
            gameState.isPaused = false;
            gameState.unlockedDefenses = ['drone'];
            gameState.lastDelayUse = 0;
            
            player = new BorderPatrolBathtub();
            lastBoatSpawn = Date.now();
            lastDroneUse = 0;
            lastFormUse = 0;
            lastPowerUpSpawn = Date.now();
            
            document.getElementById('swearingInScreen').classList.add('hidden');
            document.getElementById('gameHUD').classList.remove('hidden');
            
            // Start background music
            playSound('bgMusic', 0.1);
            
            // Start game loop
            gameLoop();
        }

        function pauseGame() {
            if (gameState.screen !== 'playing') return;
            
            gameState.isPaused = true;
            document.getElementById('pauseScreen').classList.remove('hidden');
        }

        function resumeGame() {
            gameState.isPaused = false;
            document.getElementById('pauseScreen').classList.add('hidden');
        }

        function endGame() {
            gameState.screen = 'game-over';
            
            document.getElementById('gameHUD').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.remove('hidden');
            
            const message = document.getElementById('gameOverMessage');
            const finalScore = document.getElementById('finalScore');
            
            if (gameState.score >= 500) {
                message.innerHTML = `Well done, PM ${gameState.playerName}!<br>You've successfully defended Dover!`;
            } else if (gameState.score >= 100) {
                message.innerHTML = `Not bad, PM ${gameState.playerName}!<br>Dover is mostly secure.`;
            } else {
                message.innerHTML = `The boats have landed, PM ${gameState.playerName}!<br>Time to resign and try again!`;
            }
            
            finalScore.textContent = `Final Score: ${gameState.score}`;
            
            playSound('gameOverSound');
        }

        function restartGame() {
            // Reset all screens
            document.querySelectorAll('.overlay').forEach(overlay => {
                overlay.classList.add('hidden');
            });
            document.getElementById('welcomeScreen').classList.remove('hidden');
            document.getElementById('gameHUD').classList.add('hidden');
            
            // Reset game state
            gameState.screen = 'welcome';
            gameState.score = 0;
            gameState.lives = 3;
            gameState.level = 1;
            gameState.boats = [];
            gameState.defenses = [];
            gameState.powerUps = [];
            gameState.particles = [];
            gameState.events = [];
            gameState.isPaused = false;
        }

        function backToWelcome() {
            restartGame();
        }

        // Leaderboard Functions
        async function submitScore() {
            try {
                const title = generateTitle(gameState.score, {});
                
                const response = await fetch('/api/leaderboard', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        player_name: gameState.playerName,
                        score: gameState.score,
                        title: title
                    })
                });
                
                if (response.ok) {
                    showAchievement('Score submitted to leaderboard!');
                    showLeaderboard();
                } else {
                    console.error('Failed to submit score');
                    showAchievement('Failed to submit score. Try again later.');
                }
            } catch (error) {
                console.error('Error submitting score:', error);
                showAchievement('Network error. Score not submitted.');
            }
        }

        async function showLeaderboard() {
            document.querySelectorAll('.overlay').forEach(overlay => {
                overlay.classList.add('hidden');
            });
            document.getElementById('leaderboardScreen').classList.remove('hidden');
            
            const leaderboardList = document.getElementById('leaderboardList');
            leaderboardList.innerHTML = 'Loading leaderboard...';
            
            try {
                const response = await fetch('/api/leaderboard');
                const data = await response.json();
                
                if (data.scores && data.scores.length > 0) {
                    leaderboardList.innerHTML = data.scores.map((entry, index) => {
                        const crown = index === 0 ? 'üëë ' : '';
                        const date = new Date(entry.created_at).toLocaleDateString();
                        
                        return `
                            <div class="leaderboard-item">
                                <div>${crown}PM ${entry.player_name}</div>
                                <div>${entry.title}</div>
                                <div>${entry.score} pts</div>
                                <div>${date}</div>
                            </div>
                        `;
                    }).join('');
                } else {
                    leaderboardList.innerHTML = '<div class="leaderboard-item">No scores yet. Be the first PM to defend Dover!</div>';
                }
            } catch (error) {
                console.error('Error loading leaderboard:', error);
                leaderboardList.innerHTML = '<div class="leaderboard-item">Failed to load leaderboard. Try again later.</div>';
            }
        }

        // Event Handlers
        function handleKeyDown(e) {
            gameState.keys[e.code] = true;
            
            if (gameState.screen === 'playing') {
                if (e.code === 'Space') {
                    e.preventDefault();
                    launchDrone();
                }
                if (e.code === 'KeyF' && gameState.unlockedDefenses.includes('forms')) {
                    e.preventDefault();
                    deployForms();
                }
                if (e.code === 'KeyD' && gameState.unlockedDefenses.includes('delay')) {
                    e.preventDefault();
                    activateDelay();
                }
                if (e.code === 'Escape') {
                    e.preventDefault();
                    pauseGame();
                }
            } else if (gameState.screen === 'paused' && e.code === 'Escape') {
                e.preventDefault();
                resumeGame();
            }
        }

        function handleKeyUp(e) {
            gameState.keys[e.code] = false;
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = CONFIG.canvas.width / rect.width;
            const scaleY = CONFIG.canvas.height / rect.height;
            
            gameState.mouse.x = (e.clientX - rect.left) * scaleX;
            gameState.mouse.y = (e.clientY - rect.top) * scaleY;
        }

        function handleMouseDown(e) {
            gameState.mouse.down = true;
            
            if (gameState.screen === 'playing') {
                if (e.shiftKey || e.button === 2) {
                    deployForms();
                } else {
                    launchDrone();
                }
            }
        }

        function handleMouseUp(e) {
            gameState.mouse.down = false;
        }

        // Mobile controls
        function setupMobileControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const droneBtn = document.getElementById('droneBtn');
            const formsBtn = document.getElementById('formsBtn');
            const delayBtn = document.getElementById('delayBtn');
            
            leftBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                gameState.mobile.left = true;
            });
            leftBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                gameState.mobile.left = false;
            });
            
            rightBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                gameState.mobile.right = true;
            });
            rightBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                gameState.mobile.right = false;
            });
            
            droneBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState.screen === 'playing') {
                    launchDrone();
                }
            });
            
            formsBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState.screen === 'playing' && gameState.unlockedDefenses.includes('forms')) {
                    deployForms();
                }
            });
            
            delayBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState.screen === 'playing' && gameState.unlockedDefenses.includes('delay')) {
                    activateDelay();
                }
            });
        }

        function updateMobileControls() {
            const formsBtn = document.getElementById('formsBtn');
            const delayBtn = document.getElementById('delayBtn');
            
            // Update forms button
            if (gameState.unlockedDefenses.includes('forms')) {
                formsBtn.classList.remove('disabled');
            } else {
                formsBtn.classList.add('disabled');
            }
            
            // Update delay button
            if (gameState.unlockedDefenses.includes('delay')) {
                delayBtn.classList.remove('disabled');
                const timeSinceLastDelay = Date.now() - gameState.lastDelayUse;
                if (timeSinceLastDelay < CONFIG.defenses.delay.cooldown) {
                    delayBtn.classList.add('disabled');
                } else {
                    delayBtn.classList.remove('disabled');
                }
            } else {
                delayBtn.classList.add('disabled');
            }
        }

        // Game Loop
        let lastTime = 0;
        function gameLoop(timestamp = 0) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            if (gameState.screen === 'playing') {
                updateGame(deltaTime);
                drawGame();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Initialize Game
        function initGame() {
            resizeCanvas();
            setupMobileControls();
            
            // Event listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            
            window.addEventListener('resize', resizeCanvas);
            
            // Prevent default touch behaviors
            document.addEventListener('touchstart', (e) => {
                if (e.target.tagName === 'CANVAS') {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('touchmove', (e) => {
                if (e.target.tagName === 'CANVAS') {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Start the game loop
            gameLoop();
        }

        // Start the game when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>