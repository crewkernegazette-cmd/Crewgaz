<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Dover Dash - The Crewkerne Gazette</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(45deg, #0066cc, #ff0000, #ffffff);
            background-size: 400% 400%;
            animation: unionJackGradient 3s ease infinite;
            font-family: 'Press Start 2P', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        @keyframes unionJackGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .game-container {
            position: relative;
            background: #1a1a2e;
            border: 4px solid #ff0000;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
            max-width: 95vw;
            max-height: 95vh;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, #87ceeb 0%, #e0f6ff 30%, #228b22 70%, #006400 100%);
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ffffff;
            z-index: 10;
        }

        .hidden {
            display: none !important;
        }

        .title {
            font-size: clamp(16px, 4vw, 32px);
            color: #ff0000;
            text-shadow: 2px 2px 0px #ffffff;
            margin-bottom: 20px;
            text-align: center;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        .input-group {
            margin: 20px 0;
            text-align: center;
        }

        .input-group label {
            display: block;
            font-size: clamp(8px, 2vw, 12px);
            margin-bottom: 10px;
            color: #ffffff;
        }

        .input-group input {
            font-family: 'Press Start 2P', monospace;
            font-size: clamp(8px, 2vw, 12px);
            padding: 10px;
            background: #000000;
            color: #00ff00;
            border: 2px solid #ff0000;
            border-radius: 4px;
            text-align: center;
            max-width: 200px;
        }

        .btn {
            font-family: 'Press Start 2P', monospace;
            font-size: clamp(8px, 2vw, 12px);
            padding: 15px 25px;
            margin: 10px;
            background: #ff0000;
            color: #ffffff;
            border: 2px solid #ffffff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-block;
        }

        .btn:hover {
            background: #ffffff;
            color: #ff0000;
            border-color: #ff0000;
            transform: scale(1.05);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            color: #ffffff;
            font-size: clamp(8px, 1.5vw, 12px);
            z-index: 5;
            pointer-events: none;
        }

        .hud-item {
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border: 1px solid #ff0000;
            border-radius: 4px;
        }

        .mobile-controls {
            position: absolute;
            bottom: -80px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            flex-direction: column;
            gap: 15px;
            z-index: 5;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border: 3px solid #ff0000;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
        }

        .control-panel-title {
            text-align: center;
            font-size: 10px;
            color: #00ff00;
            margin-bottom: 10px;
            text-shadow: 1px 1px 0px #000000;
        }

        .control-row {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }

        .mobile-btn {
            width: 60px;
            height: 50px;
            background: linear-gradient(145deg, #ff0000, #cc0000);
            border: 2px solid #ffffff;
            border-radius: 8px;
            color: #ffffff;
            font-size: 10px;
            cursor: pointer;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 3px 3px 0px #000000;
            transition: all 0.2s;
            font-family: 'Press Start 2P', monospace;
        }

        .mobile-btn:active {
            background: linear-gradient(145deg, #ffffff, #cccccc);
            color: #ff0000;
            transform: translate(2px, 2px);
            box-shadow: 1px 1px 0px #000000;
        }

        .mobile-btn.disabled {
            background: #666666;
            color: #999999;
            cursor: not-allowed;
        }

        .mobile-btn .btn-icon {
            font-size: 16px;
            margin-bottom: 2px;
        }

        .mobile-btn .btn-label {
            font-size: 6px;
            line-height: 1;
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
            }
        }

        @media (orientation: landscape) and (max-width: 1024px) {
            .mobile-controls {
                display: flex;
                bottom: -100px;
                transform: translateX(-50%) scale(0.8);
            }
            
            .game-container {
                margin-bottom: 120px;
            }
        }

        .leaderboard {
            max-height: 300px;
            overflow-y: auto;
            margin: 20px 0;
            width: 90%;
            max-width: 400px;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,0,0,0.2);
            border: 1px solid #ff0000;
            border-radius: 4px;
            font-size: clamp(6px, 1.5vw, 10px);
        }

        .watermark {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 8px;
            color: rgba(255,255,255,0.5);
            z-index: 15;
            pointer-events: none;
        }

        .achievement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,215,0,0.9);
            color: #000000;
            padding: 20px;
            border: 3px solid #ff0000;
            border-radius: 8px;
            font-size: clamp(10px, 2vw, 14px);
            text-align: center;
            z-index: 20;
            animation: achievementPop 3s ease-out forwards;
        }

        @keyframes achievementPop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            10% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            90% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <!-- Watermark -->
        <div class="watermark">¬© The Crewkerne Gazette</div>
        
        <!-- HUD -->
        <div class="hud hidden" id="gameHUD">
            <div class="hud-item">Score: <span id="scoreDisplay">0</span></div>
            <div class="hud-item">Lives: <span id="livesDisplay">3</span></div>
            <div class="hud-item">Level: <span id="levelDisplay">1</span></div>
            <div class="hud-item">Boats: <span id="boatsDisplay">0</span></div>
        </div>

        <!-- Mobile Controls -->
        <div class="mobile-controls" id="mobileControls">
            <div class="control-panel-title">üá¨üáß BORDER FORCE COMMAND üá¨üáß</div>
            <div class="control-row">
                <div class="mobile-btn" id="leftBtn">
                    <div class="btn-icon">‚Üê</div>
                    <div class="btn-label">LEFT</div>
                </div>
                <div class="mobile-btn" id="rightBtn">
                    <div class="btn-icon">‚Üí</div>
                    <div class="btn-label">RIGHT</div>
                </div>
            </div>
            <div class="control-row">
                <div class="mobile-btn" id="droneBtn">
                    <div class="btn-icon">üöÅ</div>
                    <div class="btn-label">DRONE</div>
                </div>
                <div class="mobile-btn disabled" id="formsBtn">
                    <div class="btn-icon">üìã</div>
                    <div class="btn-label">FORMS</div>
                </div>
                <div class="mobile-btn disabled" id="delayBtn">
                    <div class="btn-icon">‚è∏Ô∏è</div>
                    <div class="btn-label">DELAY</div>
                </div>
            </div>
        </div>

        <!-- Welcome Screen -->
        <div class="overlay" id="welcomeScreen">
            <div class="title">DOVER DASH</div>
            <p style="text-align: center; font-size: clamp(8px, 1.5vw, 12px); margin: 20px; color: #ffffff;">
                Take control as PM and protect Dover!<br>
                Intercept boats peacefully and redirect them back to France.
            </p>
            <div class="input-group">
                <label for="playerName">Enter Your Name, Future PM:</label>
                <input type="text" id="playerName" placeholder="Your Name" maxlength="20">
            </div>
            <button class="btn" onclick="startSwearingIn()">BECOME PM!</button>
            <button class="btn" onclick="showLeaderboard()">VIEW LEADERBOARD</button>
            <a href="/index.html" class="btn">BACK TO GAZETTE</a>
        </div>

        <!-- Swearing In Screen -->
        <div class="overlay hidden" id="swearingInScreen">
            <div class="title">CONGRATULATIONS!</div>
            <div id="pmAnnouncement" style="font-size: clamp(10px, 2vw, 16px); margin: 20px; text-align: center;"></div>
            <div style="font-size: clamp(12px, 3vw, 24px); margin: 20px; text-align: center; animation: blink 0.5s infinite;">
                NOW FIX THE COUNTRY!
            </div>
            <button class="btn" onclick="startGame()">START MISSION</button>
        </div>

        <!-- Game Over Screen -->
        <div class="overlay hidden" id="gameOverScreen">
            <div class="title">GAME OVER</div>
            <div id="gameOverMessage" style="font-size: clamp(10px, 2vw, 16px); margin: 20px; text-align: center;"></div>
            <div id="finalScore" style="font-size: clamp(12px, 2.5vw, 20px); margin: 20px; text-align: center; color: #00ff00;"></div>
            <button class="btn" onclick="submitScore()">SUBMIT SCORE</button>
            <button class="btn" onclick="restartGame()">TRY AGAIN</button>
            <button class="btn" onclick="showLeaderboard()">LEADERBOARD</button>
        </div>

        <!-- Leaderboard Screen -->
        <div class="overlay hidden" id="leaderboardScreen">
            <div class="title">HALL OF PRIME MINISTERS</div>
            <div class="leaderboard" id="leaderboardList">
                Loading leaderboard...
            </div>
            <button class="btn" onclick="backToWelcome()">BACK</button>
        </div>

        <!-- Pause Screen -->
        <div class="overlay hidden" id="pauseScreen">
            <div class="title">PAUSED</div>
            <p style="text-align: center; margin: 20px;">Game is paused. Press ESC or click Resume to continue.</p>
            <button class="btn" onclick="resumeGame()">RESUME</button>
            <button class="btn" onclick="restartGame()">RESTART</button>
            <button class="btn" onclick="backToWelcome()">MAIN MENU</button>
        </div>
    </div>

    <!-- Audio Elements -->
    <audio id="bgMusic" loop>
        <source src="https://www.soundjay.com/misc/sounds/8-bit-music-loop.mp3" type="audio/mpeg">
    </audio>
    <audio id="interceptSound">
        <source src="https://www.soundjay.com/misc/sounds/beep-07.mp3" type="audio/mpeg">
    </audio>
    <audio id="scoreSound">
        <source src="https://www.soundjay.com/misc/sounds/beep-10.mp3" type="audio/mpeg">
    </audio>
    <audio id="gameOverSound">
        <source src="https://www.soundjay.com/misc/sounds/game-over.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Game State
        let gameState = {
            screen: 'welcome', // welcome, swearing-in, playing, paused, game-over, leaderboard
            score: 0,
            lives: 3,
            level: 1,
            wave: 1,
            waveStartTime: 0,
            isWaveBreak: false,
            waveBreakStartTime: 0,
            playerName: '',
            boats: [],
            defenses: [],
            powerUps: [],
            particles: [],
            events: [],
            achievements: [],
            lastEventTime: 0,
            gameTime: 0,
            isPaused: false,
            keys: {},
            mouse: { x: 0, y: 0, down: false },
            mobile: { left: false, right: false, drone: false, forms: false, delay: false },
            unlockedDefenses: ['drone'], // Start with drone unlocked
            lastDelayUse: 0
        };

        // Game Configuration
        const CONFIG = {
            canvas: { width: 800, height: 600 },
            fps: 60,
            boats: {
                baseSpawnRate: 4000, // milliseconds - starts slow
                minSpawnRate: 800,   // fastest spawn rate
                speedIncrease: 0.3,  // speed increase per level
                baseSpeed: 0.8,      // starting speed
                size: { width: 30, height: 20 }
            },
            waves: {
                duration: 30000,     // 30 seconds per wave
                breakDuration: 5000, // 5 second break between waves
                difficultyIncrease: 1.5 // multiplier per wave
            },
            player: {
                speed: 5,
                size: { width: 80, height: 20 }
            },
            defenses: {
                drone: { speed: 3, size: 15, cooldown: 2000 },
                forms: { speed: 2, size: 25, cooldown: 4000, unlockScore: 100 },
                delay: { cooldown: 25000, cost: 50, duration: 5000, unlockScore: 300 }
            },
            powerUps: {
                spawnRate: 20000,
                duration: 15000
            },
            events: {
                interval: 45000, // 45 seconds
                duration: 15000  // 15 seconds
            }
        };

        // Canvas and Context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Make canvas responsive
        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerRect = container.getBoundingClientRect();
            const aspectRatio = CONFIG.canvas.width / CONFIG.canvas.height;
            
            let newWidth = Math.min(containerRect.width - 8, window.innerWidth - 20);
            let newHeight = newWidth / aspectRatio;
            
            if (newHeight > window.innerHeight - 100) {
                newHeight = window.innerHeight - 100;
                newWidth = newHeight * aspectRatio;
            }
            
            canvas.style.width = newWidth + 'px';
            canvas.style.height = newHeight + 'px';
        }

        // Game Classes
        class Boat {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = CONFIG.boats.size.width;
                this.height = CONFIG.boats.size.height;
                this.speed = CONFIG.boats.baseSpeed + (gameState.wave * CONFIG.boats.speedIncrease);
                this.intercepted = false;
                this.redirecting = false;
                this.redirectSpeed = 2;
                this.bobOffset = Math.random() * Math.PI * 2;
            }

            update(deltaTime) {
                if (this.redirecting) {
                    this.x += this.redirectSpeed;
                    this.y += Math.sin(Date.now() * 0.005 + this.bobOffset) * 0.5;
                } else {
                    this.x -= this.speed * (deltaTime / 16);
                    this.y += Math.sin(Date.now() * 0.003 + this.bobOffset) * 0.3;
                }
            }

            draw(ctx) {
                ctx.save();
                
                // Boat body
                ctx.fillStyle = this.redirecting ? '#90EE90' : '#8B4513';
                ctx.fillRect(this.x, this.y + 10, this.width, this.height - 10);
                
                // Sail
                ctx.fillStyle = this.redirecting ? '#98FB98' : '#FFFFFF';
                ctx.fillRect(this.x + 10, this.y, 15, 15);
                
                // Mast
                ctx.fillStyle = '#654321';
                ctx.fillRect(this.x + 17, this.y, 2, this.height);
                
                // Flag (French or British depending on direction)
                if (this.redirecting) {
                    // Union Jack
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(this.x + 5, this.y, 8, 6);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(this.x + 6, this.y + 2, 6, 2);
                    ctx.fillStyle = '#0000FF';
                    ctx.fillRect(this.x + 7, this.y + 1, 4, 4);
                } else {
                    // French tricolor
                    ctx.fillStyle = '#0055A4';
                    ctx.fillRect(this.x + 5, this.y, 3, 6);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(this.x + 8, this.y, 2, 6);
                    ctx.fillStyle = '#EF4135';
                    ctx.fillRect(this.x + 10, this.y, 3, 6);
                }
                
                ctx.restore();
            }

            intercept() {
                if (!this.intercepted) {
                    this.intercepted = true;
                    this.redirecting = true;
                    gameState.score += 10;
                    playSound('interceptSound');
                    createParticles(this.x + this.width/2, this.y + this.height/2, '#00FF00', 'INTERCEPTED!');
                }
            }

            isOffScreen() {
                return this.x < -this.width || this.x > CONFIG.canvas.width + this.width;
            }

            reachedDover() {
                return this.x <= 0 && !this.intercepted;
            }
        }

        class BorderPatrolBathtub {
            constructor() {
                this.x = CONFIG.canvas.width / 2 - CONFIG.player.size.width / 2;
                this.y = CONFIG.canvas.height - CONFIG.player.size.height - 20;
                this.width = CONFIG.player.size.width;
                this.height = CONFIG.player.size.height;
                this.speed = CONFIG.player.speed;
            }

            update() {
                // Handle input
                if (gameState.keys['ArrowLeft'] || gameState.mobile.left) {
                    this.x = Math.max(0, this.x - this.speed);
                }
                if (gameState.keys['ArrowRight'] || gameState.mobile.right) {
                    this.x = Math.min(CONFIG.canvas.width - this.width, this.x + this.speed);
                }
            }

            draw(ctx) {
                ctx.save();
                
                // Bathtub body
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                
                // Union Jack
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(this.x + 10, this.y + 5, 20, 10);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(this.x + 12, this.y + 7, 16, 6);
                ctx.fillStyle = '#0000FF';
                ctx.fillRect(this.x + 14, this.y + 8, 12, 4);
                
                // Border Force text
                ctx.fillStyle = '#000000';
                ctx.font = '8px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText('BORDER FORCE', this.x + this.width/2, this.y - 5);
                
                ctx.restore();
            }

            checkCollision(boat) {
                return this.x < boat.x + boat.width &&
                       this.x + this.width > boat.x &&
                       this.y < boat.y + boat.height &&
                       this.y + this.height > boat.y;
            }
        }

        class Drone {
            constructor(x, y, targetX, targetY) {
                this.x = x;
                this.y = y;
                this.targetX = targetX;
                this.targetY = targetY;
                this.size = CONFIG.defenses.drone.size;
                this.speed = CONFIG.defenses.drone.speed;
                this.active = true;
                this.life = 3000; // 3 seconds
            }

            update(deltaTime) {
                if (!this.active) return;
                
                this.life -= deltaTime;
                if (this.life <= 0) {
                    this.active = false;
                    return;
                }

                // Move towards target
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 2) {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }
            }

            draw(ctx) {
                if (!this.active) return;
                
                ctx.save();
                
                // Drone body
                ctx.fillStyle = '#4169E1';
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                
                // Rotors
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1;
                const rotorOffset = this.size * 0.6;
                const time = Date.now() * 0.01;
                
                // Spinning rotor effect
                for (let i = 0; i < 4; i++) {
                    const angle = (Math.PI / 2) * i + time;
                    const x = this.x + Math.cos(angle) * rotorOffset;
                    const y = this.y + Math.sin(angle) * rotorOffset;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            }

            checkCollision(boat) {
                if (!this.active) return false;
                
                const dx = this.x - (boat.x + boat.width/2);
                const dy = this.y - (boat.y + boat.height/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                return distance < this.size;
            }
        }

        class BureaucracyForm {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 25;
                this.height = 35;
                this.speed = 2;
                this.rotation = 0;
                this.active = true;
                this.life = 5000; // 5 seconds
            }

            update(deltaTime) {
                if (!this.active) return;
                
                this.life -= deltaTime;
                if (this.life <= 0) {
                    this.active = false;
                    return;
                }

                this.y += this.speed * (deltaTime / 16);
                this.rotation += 0.05;
            }

            draw(ctx) {
                if (!this.active) return;
                
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(this.rotation);
                
                // Form paper
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1;
                ctx.strokeRect(-this.width/2, -this.height/2, this.width, this.height);
                
                // Text lines
                ctx.strokeStyle = '#0000FF';
                for (let i = 0; i < 5; i++) {
                    const y = -10 + (i * 4);
                    ctx.beginPath();
                    ctx.moveTo(-8, y);
                    ctx.lineTo(8, y);
                    ctx.stroke();
                }
                
                // "FORM 27B" text
                ctx.fillStyle = '#FF0000';
                ctx.font = '6px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('FORM', 0, -15);
                ctx.fillText('27B', 0, -8);
                
                ctx.restore();
            }

            checkCollision(boat) {
                if (!this.active) return false;
                
                return this.x < boat.x + boat.width &&
                       this.x + this.width > boat.x &&
                       this.y < boat.y + boat.height &&
                       this.y + this.height > boat.y;
            }
        }

        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // 'teapot', 'crumpet', 'crown'
                this.size = 20;
                this.bobOffset = Math.random() * Math.PI * 2;
                this.collected = false;
                this.life = CONFIG.powerUps.duration;
            }

            update(deltaTime) {
                this.life -= deltaTime;
                this.y += Math.sin(Date.now() * 0.005 + this.bobOffset) * 0.5;
            }

            draw(ctx) {
                ctx.save();
                
                const centerX = this.x + this.size/2;
                const centerY = this.y + this.size/2;
                
                switch(this.type) {
                    case 'teapot':
                        // Teapot (score multiplier)
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(this.x + 5, this.y + 8, 10, 8);
                        ctx.fillRect(this.x + 15, this.y + 10, 3, 2); // spout
                        ctx.fillRect(this.x + 2, this.y + 9, 3, 4); // handle
                        ctx.fillStyle = '#FFD700';
                        ctx.fillRect(this.x + 8, this.y + 5, 4, 3); // lid
                        break;
                        
                    case 'crumpet':
                        // Crumpet (temporary invincibility)
                        ctx.fillStyle = '#DEB887';
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, this.size/2, 0, Math.PI * 2);
                        ctx.fill();
                        // Holes
                        ctx.fillStyle = '#8B7355';
                        for (let i = 0; i < 6; i++) {
                            const angle = (Math.PI * 2 / 6) * i;
                            const holeX = centerX + Math.cos(angle) * 5;
                            const holeY = centerY + Math.sin(angle) * 5;
                            ctx.beginPath();
                            ctx.arc(holeX, holeY, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                        
                    case 'crown':
                        // Crown (bonus points)
                        ctx.fillStyle = '#FFD700';
                        ctx.fillRect(this.x + 3, this.y + 12, 14, 6);
                        // Crown points
                        for (let i = 0; i < 5; i++) {
                            const x = this.x + 4 + (i * 2.5);
                            const height = (i % 2 === 0) ? 8 : 5;
                            ctx.fillRect(x, this.y + 12 - height, 2, height);
                        }
                        // Jewels
                        ctx.fillStyle = '#FF0000';
                        ctx.fillRect(this.x + 9, this.y + 14, 2, 2);
                        break;
                }
                
                ctx.restore();
            }

            checkCollision(bathtub) {
                return this.x < bathtub.x + bathtub.width &&
                       this.x + this.size > bathtub.x &&
                       this.y < bathtub.y + bathtub.height &&
                       this.y + this.size > bathtub.y;
            }
        }

        class Particle {
            constructor(x, y, color, text = '') {
                this.x = x;
                this.y = y;
                this.color = color;
                this.text = text;
                this.life = 60; // frames
                this.velocity = {
                    x: (Math.random() - 0.5) * 2,
                    y: -Math.random() * 3 - 1
                };
                this.size = Math.random() * 4 + 2;
            }

            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.velocity.y += 0.1; // gravity
                this.life--;
                this.size *= 0.98;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life / 60;
                
                if (this.text) {
                    ctx.fillStyle = this.color;
                    ctx.font = '12px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.text, this.x, this.y);
                } else {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // Game Objects
        let player = new BorderPatrolBathtub();
        let lastBoatSpawn = 0;
        let lastDroneUse = 0;
        let lastFormUse = 0;
        let lastPowerUpSpawn = 0;

        // Utility Functions
        function createParticles(x, y, color, text = '') {
            for (let i = 0; i < (text ? 1 : 8); i++) {
                gameState.particles.push(new Particle(x, y, color, i === 0 ? text : ''));
            }
        }

        function playSound(soundId, volume = 0.3) {
            try {
                const audio = document.getElementById(soundId);
                if (audio) {
                    audio.volume = volume;
                    audio.currentTime = 0;
                    audio.play().catch(e => console.log('Audio play failed:', e));
                }
            } catch (e) {
                console.log('Audio error:', e);
            }
        }

        function showAchievement(text) {
            const achievement = document.createElement('div');
            achievement.className = 'achievement';
            achievement.innerHTML = `üèÜ ACHIEVEMENT UNLOCKED!<br>${text}`;
            document.querySelector('.game-container').appendChild(achievement);
            
            setTimeout(() => {
                if (achievement.parentNode) {
                    achievement.parentNode.removeChild(achievement);
                }
            }, 3000);
        }

        function generateTitle(score, stats) {
            if (score >= 1000) return "Defender of Dover";
            if (score >= 500) return "Border Patrol Champion";
            if (score >= 250) return "Channel Guardian";
            if (score >= 100) return "Boat Interceptor";
            if (score >= 50) return "Dover Deputy";
            return "Rookie PM";
        }

        function spawnBoat() {
            const y = Math.random() * (CONFIG.canvas.height - 200) + 100;
            gameState.boats.push(new Boat(CONFIG.canvas.width, y));
        }

        function spawnPowerUp() {
            const types = ['teapot', 'crumpet', 'crown'];
            const type = types[Math.floor(Math.random() * types.length)];
            const x = Math.random() * (CONFIG.canvas.width - 50) + 25;
            const y = Math.random() * (CONFIG.canvas.height - 300) + 100;
            gameState.powerUps.push(new PowerUp(x, y, type));
        }

        function launchDrone() {
            if (Date.now() - lastDroneUse < CONFIG.defenses.drone.cooldown) return;
            
            // Find nearest boat
            let nearestBoat = null;
            let nearestDistance = Infinity;
            
            gameState.boats.forEach(boat => {
                if (!boat.intercepted) {
                    const distance = Math.abs(boat.x - player.x);
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestBoat = boat;
                    }
                }
            });
            
            if (nearestBoat) {
                gameState.defenses.push(new Drone(
                    player.x + player.width/2,
                    player.y,
                    nearestBoat.x + nearestBoat.width/2,
                    nearestBoat.y + nearestBoat.height/2
                ));
                lastDroneUse = Date.now();
                playSound('scoreSound');
            }
        }

        function deployForms() {
            if (Date.now() - lastFormUse < CONFIG.defenses.forms.cooldown) return;
            
            for (let i = 0; i < 3; i++) {
                const x = Math.random() * CONFIG.canvas.width;
                const y = -30;
                gameState.defenses.push(new BureaucracyForm(x, y));
            }
            lastFormUse = Date.now();
            playSound('scoreSound');
        }

        function triggerRandomEvent() {
            const events = [
                {
                    name: "Matt Hancock Dancing",
                    message: "Matt Hancock is dancing on screen!",
                    effect: () => {
                        // Block part of screen temporarily
                        gameState.events.push({
                            type: 'screen_block',
                            duration: 5000,
                            startTime: Date.now()
                        });
                    }
                },
                {
                    name: "Nigel Farage Karaoke",
                    message: "Nigel's karaoke distracts the boats!",
                    effect: () => {
                        gameState.boats.forEach(boat => {
                            if (!boat.intercepted) {
                                boat.speed *= 0.5; // Slow down boats
                            }
                        });
                        setTimeout(() => {
                            gameState.boats.forEach(boat => {
                                boat.speed /= 0.5; // Restore speed
                            });
                        }, 8000);
                    }
                },
                {
                    name: "King Charles Weather Forecast",
                    message: "Royal weather report causes rough seas!",
                    effect: () => {
                        gameState.boats.forEach(boat => {
                            boat.bobOffset += Math.PI; // Increase bobbing
                        });
                    }
                }
            ];
            
            const event = events[Math.floor(Math.random() * events.length)];
            event.effect();
            createParticles(CONFIG.canvas.width/2, 100, '#FFD700', event.message);
        }

        // Game Loop Functions
        function updateGame(deltaTime) {
            if (gameState.isPaused) return;
            
            gameState.gameTime += deltaTime;
            
            // Spawn boats
            if (Date.now() - lastBoatSpawn > CONFIG.boats.spawnRate / gameState.level) {
                spawnBoat();
                lastBoatSpawn = Date.now();
            }
            
            // Spawn power-ups
            if (Date.now() - lastPowerUpSpawn > CONFIG.powerUps.spawnRate) {
                spawnPowerUp();
                lastPowerUpSpawn = Date.now();
            }
            
            // Trigger random events
            if (Date.now() - gameState.lastEventTime > CONFIG.events.interval) {
                triggerRandomEvent();
                gameState.lastEventTime = Date.now();
            }
            
            // Update player
            player.update();
            
            // Update boats
            gameState.boats.forEach(boat => {
                boat.update(deltaTime);
                
                // Check collision with player
                if (player.checkCollision(boat) && !boat.intercepted) {
                    boat.intercept();
                }
                
                // Check if boat reached Dover
                if (boat.reachedDover()) {
                    gameState.lives--;
                    gameState.score = Math.max(0, gameState.score - 20);
                    boat.intercepted = true; // Prevent multiple hits
                    createParticles(boat.x, boat.y, '#FF0000', 'BOAT LANDED!');
                    playSound('gameOverSound', 0.2);
                }
            });
            
            // Update defenses
            gameState.defenses.forEach(defense => {
                defense.update(deltaTime);
                
                // Check collisions with boats
                gameState.boats.forEach(boat => {
                    if (!boat.intercepted && defense.checkCollision && defense.checkCollision(boat)) {
                        boat.intercept();
                        if (defense.active !== undefined) {
                            defense.active = false;
                        }
                    }
                });
            });
            
            // Update power-ups
            gameState.powerUps.forEach(powerUp => {
                powerUp.update(deltaTime);
                
                if (!powerUp.collected && powerUp.checkCollision(player)) {
                    powerUp.collected = true;
                    
                    switch(powerUp.type) {
                        case 'teapot':
                            gameState.score += 50;
                            createParticles(powerUp.x, powerUp.y, '#FFD700', '+50 TEA BONUS!');
                            break;
                        case 'crumpet':
                            // Temporary invincibility (visual effect only in this demo)
                            gameState.score += 25;
                            createParticles(powerUp.x, powerUp.y, '#90EE90', 'CRUMPET POWER!');
                            break;
                        case 'crown':
                            gameState.score += 100;
                            createParticles(powerUp.x, powerUp.y, '#FFD700', '+100 ROYAL BONUS!');
                            break;
                    }
                    playSound('scoreSound');
                }
            });
            
            // Update particles
            gameState.particles.forEach(particle => {
                particle.update();
            });
            
            // Clean up dead objects
            gameState.boats = gameState.boats.filter(boat => !boat.isOffScreen());
            gameState.defenses = gameState.defenses.filter(defense => 
                defense.active === undefined || defense.active
            );
            gameState.powerUps = gameState.powerUps.filter(powerUp => 
                powerUp.life > 0 && !powerUp.collected
            );
            gameState.particles = gameState.particles.filter(particle => particle.life > 0);
            
            // Level progression
            const newLevel = Math.floor(gameState.score / 200) + 1;
            if (newLevel > gameState.level) {
                gameState.level = newLevel;
                createParticles(CONFIG.canvas.width/2, CONFIG.canvas.height/2, '#FFD700', `LEVEL ${gameState.level}!`);
                playSound('scoreSound');
            }
            
            // Check game over
            if (gameState.lives <= 0) {
                endGame();
            }
            
            // Update HUD
            updateHUD();
        }

        function drawGame() {
            // Clear canvas with gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.canvas.height);
            gradient.addColorStop(0, '#87CEEB'); // Sky blue
            gradient.addColorStop(0.3, '#E0F6FF'); // Light blue
            gradient.addColorStop(0.7, '#228B22'); // Forest green
            gradient.addColorStop(1, '#006400');   // Dark green
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);
            
            // Draw Dover cliffs (left side)
            ctx.fillStyle = '#F5F5DC';
            ctx.fillRect(0, CONFIG.canvas.height * 0.4, 50, CONFIG.canvas.height * 0.6);
            
            // Draw France coastline (right side)
            ctx.fillStyle = '#D2B48C';
            ctx.fillRect(CONFIG.canvas.width - 30, CONFIG.canvas.height * 0.5, 30, CONFIG.canvas.height * 0.5);
            
            // Draw water
            ctx.fillStyle = '#4682B4';
            ctx.globalAlpha = 0.7;
            ctx.fillRect(50, CONFIG.canvas.height * 0.4, CONFIG.canvas.width - 80, CONFIG.canvas.height * 0.6);
            ctx.globalAlpha = 1;
            
            // Draw wave effects
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            const waveOffset = Date.now() * 0.005;
            for (let x = 50; x < CONFIG.canvas.width - 30; x += 20) {
                for (let y = CONFIG.canvas.height * 0.5; y < CONFIG.canvas.height; y += 40) {
                    const waveY = y + Math.sin(x * 0.02 + waveOffset) * 3;
                    ctx.beginPath();
                    ctx.moveTo(x, waveY);
                    ctx.lineTo(x + 10, waveY);
                    ctx.stroke();
                }
            }
            
            // Draw objects
            gameState.boats.forEach(boat => boat.draw(ctx));
            gameState.defenses.forEach(defense => defense.draw(ctx));
            gameState.powerUps.forEach(powerUp => powerUp.draw(ctx));
            player.draw(ctx);
            gameState.particles.forEach(particle => particle.draw(ctx));
            
            // Draw event effects
            gameState.events.forEach(event => {
                if (event.type === 'screen_block') {
                    const elapsed = Date.now() - event.startTime;
                    if (elapsed < event.duration) {
                        ctx.fillStyle = 'rgba(255, 0, 255, 0.3)';
                        ctx.fillRect(CONFIG.canvas.width * 0.3, 0, CONFIG.canvas.width * 0.4, CONFIG.canvas.height);
                        
                        ctx.fillStyle = '#FF00FF';
                        ctx.font = '16px "Press Start 2P"';
                        ctx.textAlign = 'center';
                        ctx.fillText('MATT DANCING!', CONFIG.canvas.width/2, CONFIG.canvas.height/2);
                    }
                }
            });
        }

        function updateHUD() {
            document.getElementById('scoreDisplay').textContent = gameState.score;
            document.getElementById('livesDisplay').textContent = gameState.lives;
            document.getElementById('levelDisplay').textContent = gameState.level;
            document.getElementById('boatsDisplay').textContent = gameState.boats.filter(b => !b.intercepted).length;
        }

        // Game State Functions
        function startSwearingIn() {
            const name = document.getElementById('playerName').value.trim();
            if (!name) {
                alert('Please enter your name, future PM!');
                return;
            }
            
            gameState.playerName = name;
            gameState.screen = 'swearing-in';
            
            document.getElementById('welcomeScreen').classList.add('hidden');
            document.getElementById('swearingInScreen').classList.remove('hidden');
            
            const announcement = document.getElementById('pmAnnouncement');
            announcement.innerHTML = `PM ${name.toUpperCase()}!<br>üéâ SWORN IN AS PRIME MINISTER! üéâ`;
            
            // Play ceremony sound
            playSound('scoreSound');
            
            // Create confetti effect
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    createParticles(
                        Math.random() * CONFIG.canvas.width,
                        -10,
                        ['#FF0000', '#FFFFFF', '#0000FF'][Math.floor(Math.random() * 3)]
                    );
                }, i * 100);
            }
        }

        function startGame() {
            gameState.screen = 'playing';
            gameState.score = 0;
            gameState.lives = 3;
            gameState.level = 1;
            gameState.boats = [];
            gameState.defenses = [];
            gameState.powerUps = [];
            gameState.particles = [];
            gameState.events = [];
            gameState.gameTime = 0;
            gameState.lastEventTime = Date.now();
            gameState.isPaused = false;
            
            player = new BorderPatrolBathtub();
            lastBoatSpawn = Date.now();
            lastDroneUse = 0;
            lastFormUse = 0;
            lastPowerUpSpawn = Date.now();
            
            document.getElementById('swearingInScreen').classList.add('hidden');
            document.getElementById('gameHUD').classList.remove('hidden');
            
            // Start background music
            playSound('bgMusic', 0.1);
            
            // Start game loop
            gameLoop();
        }

        function pauseGame() {
            if (gameState.screen !== 'playing') return;
            
            gameState.isPaused = true;
            document.getElementById('pauseScreen').classList.remove('hidden');
        }

        function resumeGame() {
            gameState.isPaused = false;
            document.getElementById('pauseScreen').classList.add('hidden');
        }

        function endGame() {
            gameState.screen = 'game-over';
            
            document.getElementById('gameHUD').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.remove('hidden');
            
            const message = document.getElementById('gameOverMessage');
            const finalScore = document.getElementById('finalScore');
            
            if (gameState.score >= 500) {
                message.innerHTML = `Well done, PM ${gameState.playerName}!<br>You've successfully defended Dover!`;
            } else if (gameState.score >= 100) {
                message.innerHTML = `Not bad, PM ${gameState.playerName}!<br>Dover is mostly secure.`;
            } else {
                message.innerHTML = `The boats have landed, PM ${gameState.playerName}!<br>Time to resign and try again!`;
            }
            
            finalScore.textContent = `Final Score: ${gameState.score}`;
            
            playSound('gameOverSound');
        }

        function restartGame() {
            // Reset all screens
            document.querySelectorAll('.overlay').forEach(overlay => {
                overlay.classList.add('hidden');
            });
            document.getElementById('welcomeScreen').classList.remove('hidden');
            document.getElementById('gameHUD').classList.add('hidden');
            
            // Reset game state
            gameState.screen = 'welcome';
            gameState.score = 0;
            gameState.lives = 3;
            gameState.level = 1;
            gameState.boats = [];
            gameState.defenses = [];
            gameState.powerUps = [];
            gameState.particles = [];
            gameState.events = [];
            gameState.isPaused = false;
        }

        function backToWelcome() {
            restartGame();
        }

        // Leaderboard Functions
        async function submitScore() {
            try {
                const title = generateTitle(gameState.score, {});
                
                const response = await fetch('/api/leaderboard', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        player_name: gameState.playerName,
                        score: gameState.score,
                        title: title
                    })
                });
                
                if (response.ok) {
                    showAchievement('Score submitted to leaderboard!');
                    showLeaderboard();
                } else {
                    console.error('Failed to submit score');
                    showAchievement('Failed to submit score. Try again later.');
                }
            } catch (error) {
                console.error('Error submitting score:', error);
                showAchievement('Network error. Score not submitted.');
            }
        }

        async function showLeaderboard() {
            document.querySelectorAll('.overlay').forEach(overlay => {
                overlay.classList.add('hidden');
            });
            document.getElementById('leaderboardScreen').classList.remove('hidden');
            
            const leaderboardList = document.getElementById('leaderboardList');
            leaderboardList.innerHTML = 'Loading leaderboard...';
            
            try {
                const response = await fetch('/api/leaderboard');
                const data = await response.json();
                
                if (data.scores && data.scores.length > 0) {
                    leaderboardList.innerHTML = data.scores.map((entry, index) => {
                        const crown = index === 0 ? 'üëë ' : '';
                        const date = new Date(entry.created_at).toLocaleDateString();
                        
                        return `
                            <div class="leaderboard-item">
                                <div>${crown}PM ${entry.player_name}</div>
                                <div>${entry.title}</div>
                                <div>${entry.score} pts</div>
                                <div>${date}</div>
                            </div>
                        `;
                    }).join('');
                } else {
                    leaderboardList.innerHTML = '<div class="leaderboard-item">No scores yet. Be the first PM to defend Dover!</div>';
                }
            } catch (error) {
                console.error('Error loading leaderboard:', error);
                leaderboardList.innerHTML = '<div class="leaderboard-item">Failed to load leaderboard. Try again later.</div>';
            }
        }

        // Event Handlers
        function handleKeyDown(e) {
            gameState.keys[e.code] = true;
            
            if (gameState.screen === 'playing') {
                if (e.code === 'Space') {
                    e.preventDefault();
                    if (e.shiftKey) {
                        deployForms();
                    } else {
                        launchDrone();
                    }
                }
                if (e.code === 'Escape') {
                    e.preventDefault();
                    pauseGame();
                }
            } else if (gameState.screen === 'paused' && e.code === 'Escape') {
                e.preventDefault();
                resumeGame();
            }
        }

        function handleKeyUp(e) {
            gameState.keys[e.code] = false;
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = CONFIG.canvas.width / rect.width;
            const scaleY = CONFIG.canvas.height / rect.height;
            
            gameState.mouse.x = (e.clientX - rect.left) * scaleX;
            gameState.mouse.y = (e.clientY - rect.top) * scaleY;
        }

        function handleMouseDown(e) {
            gameState.mouse.down = true;
            
            if (gameState.screen === 'playing') {
                if (e.shiftKey || e.button === 2) {
                    deployForms();
                } else {
                    launchDrone();
                }
            }
        }

        function handleMouseUp(e) {
            gameState.mouse.down = false;
        }

        // Mobile controls
        function setupMobileControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const actionBtn = document.getElementById('actionBtn');
            
            leftBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                gameState.mobile.left = true;
            });
            leftBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                gameState.mobile.left = false;
            });
            
            rightBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                gameState.mobile.right = true;
            });
            rightBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                gameState.mobile.right = false;
            });
            
            actionBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState.screen === 'playing') {
                    launchDrone();
                }
            });
        }

        // Game Loop
        let lastTime = 0;
        function gameLoop(timestamp = 0) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            if (gameState.screen === 'playing') {
                updateGame(deltaTime);
                drawGame();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Initialize Game
        function initGame() {
            resizeCanvas();
            setupMobileControls();
            
            // Event listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            
            window.addEventListener('resize', resizeCanvas);
            
            // Prevent default touch behaviors
            document.addEventListener('touchstart', (e) => {
                if (e.target.tagName === 'CANVAS') {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('touchmove', (e) => {
                if (e.target.tagName === 'CANVAS') {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Start the game loop
            gameLoop();
        }

        // Start the game when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>